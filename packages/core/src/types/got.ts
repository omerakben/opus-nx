/**
 * @scope active
 */
import { z } from "zod";
import { EdgeTypeSchema } from "./thinking.js";

// ============================================================
// [Future Scope] Graph of Thoughts (GoT) Types
// ============================================================
// Based on: "Graph of Thoughts: Solving Elaborate Problems with LLMs"
// (Besta et al., 2023 — arXiv:2308.09687)
//
// GoT models LLM reasoning as an arbitrary directed graph where:
// - Vertices = individual thoughts (coherent reasoning units)
// - Edges = dependencies between thoughts
// - Transformations = operations that modify the graph
//
// This generalizes both Chain-of-Thought (linear) and
// Tree-of-Thoughts (hierarchical) into arbitrary topologies.
// ============================================================

// ============================================================
// Thought States
// ============================================================

/** State of a thought in the reasoning graph */
export const ThoughtStateSchema = z.enum([
  "pending",     // Queued for generation
  "generating",  // Currently being generated by LLM
  "generated",   // Generated but not yet evaluated
  "evaluating",  // Being scored/verified
  "verified",    // Passed verification
  "rejected",    // Failed verification
  "aggregated",  // Merged into another thought
  "refined",     // Superseded by a refined version
]);

export type ThoughtState = z.infer<typeof ThoughtStateSchema>;

// ============================================================
// Thought (Vertex in GoT)
// ============================================================

/** A single thought — the fundamental unit in GoT */
export const ThoughtSchema = z.object({
  id: z.string().uuid(),
  /** Content of the thought */
  content: z.string(),
  /** Current state in the processing pipeline */
  state: ThoughtStateSchema,
  /** Score from the Process Reward Model (0-1) */
  score: z.number().min(0).max(1).nullable().default(null),
  /** Depth in the reasoning graph (0 = root) */
  depth: z.number().int().min(0),
  /** Which transformation created this thought */
  origin: z.enum(["generation", "aggregation", "refinement", "user_input", "seed"]),
  /** IDs of parent thoughts (empty for root thoughts) */
  parentIds: z.array(z.string().uuid()).default([]),
  /** IDs of child thoughts */
  childIds: z.array(z.string().uuid()).default([]),
  /** Metadata for visualization and analysis */
  metadata: z.object({
    /** Step number in the reasoning chain */
    stepNumber: z.number().int().optional(),
    /** Token count for this thought */
    tokenCount: z.number().int().optional(),
    /** Which LLM call produced this thought */
    generationId: z.string().optional(),
    /** Time taken to generate in ms */
    generationMs: z.number().optional(),
    /** Tags for categorization */
    tags: z.array(z.string()).optional(),
  }).default({}),
  createdAt: z.date(),
  updatedAt: z.date(),
});

export type Thought = z.infer<typeof ThoughtSchema>;

// ============================================================
// Thought Transformations
// ============================================================

/**
 * Transformation types that modify the GoT graph.
 * These are the core operations from the GoT paper.
 */
export const TransformationTypeSchema = z.enum([
  "generate",    // Create new thoughts from existing ones
  "aggregate",   // Merge multiple thoughts into one
  "refine",      // Improve a thought through feedback
  "score",       // Evaluate a thought's quality
  "keep_best",   // Select the best k thoughts from a set
  "ground_truth_evaluate", // Compare against known answer
]);

export type TransformationType = z.infer<typeof TransformationTypeSchema>;

/** A transformation operation in the Graph of Operations (GoO) */
export const TransformationSchema = z.object({
  id: z.string().uuid(),
  type: TransformationTypeSchema,
  /** Input thought IDs */
  inputIds: z.array(z.string().uuid()),
  /** Output thought IDs (populated after execution) */
  outputIds: z.array(z.string().uuid()).default([]),
  /** Configuration for this transformation */
  config: z.object({
    /** Number of thoughts to generate (for 'generate') */
    k: z.number().int().min(1).default(3),
    /** Prompt template for the transformation */
    promptTemplate: z.string().optional(),
    /** Temperature for generation */
    temperature: z.number().min(0).max(1).optional(),
    /** Whether to allow backtracking from this transformation */
    allowBacktrack: z.boolean().default(true),
  }).default({}),
  /** Execution status */
  status: z.enum(["pending", "executing", "completed", "failed"]),
  /** Error message if failed */
  error: z.string().optional(),
  /** Execution metrics */
  metrics: z.object({
    startTime: z.date().optional(),
    endTime: z.date().optional(),
    tokensUsed: z.number().optional(),
  }).default({}),
});

export type Transformation = z.infer<typeof TransformationSchema>;

// ============================================================
// Graph of Operations (GoO) — Execution Plan
// ============================================================

/**
 * GoO defines the execution plan as a DAG of transformations.
 * It specifies what operations to perform and in what order.
 */
export const GraphOfOperationsSchema = z.object({
  id: z.string().uuid(),
  /** Human-readable description of this operation plan */
  description: z.string(),
  /** Ordered list of transformation steps */
  steps: z.array(TransformationSchema),
  /** Current step index being executed */
  currentStep: z.number().int().default(0),
  /** Overall status */
  status: z.enum(["planning", "executing", "completed", "failed", "paused"]),
});

export type GraphOfOperations = z.infer<typeof GraphOfOperationsSchema>;

// ============================================================
// Graph Reasoning State (GRS) — Full State
// ============================================================

/**
 * GRS tracks the complete state of a GoT reasoning session.
 * Includes all thoughts, edges, transformations, and history.
 */
export const GraphReasoningStateSchema = z.object({
  /** Session this reasoning belongs to */
  sessionId: z.string().uuid(),
  /** All thoughts in the graph */
  thoughts: z.array(ThoughtSchema),
  /** Edges between thoughts */
  edges: z.array(z.object({
    sourceId: z.string().uuid(),
    targetId: z.string().uuid(),
    type: EdgeTypeSchema,
    weight: z.number().min(0).max(1).default(1.0),
  })),
  /** The execution plan */
  operations: GraphOfOperationsSchema.optional(),
  /** Best thought(s) found so far */
  bestThoughts: z.array(z.string().uuid()).default([]),
  /** Total tokens consumed */
  totalTokens: z.number().default(0),
  /** Total time in ms */
  totalDurationMs: z.number().default(0),
});

export type GraphReasoningState = z.infer<typeof GraphReasoningStateSchema>;

// ============================================================
// GoT Search Strategies (from ToT paper)
// ============================================================

/** Search strategy for exploring the thought graph */
export const SearchStrategySchema = z.enum([
  "bfs",     // Breadth-first: explore level by level, keep top-k per level
  "dfs",     // Depth-first: explore deepest branch first, backtrack on failure
  "best_first", // Always expand the highest-scored thought next
]);

export type SearchStrategy = z.infer<typeof SearchStrategySchema>;

/** Configuration for GoT reasoning */
export const GoTConfigSchema = z.object({
  /** Search strategy to use */
  strategy: SearchStrategySchema.default("bfs"),
  /** Maximum depth of the thought graph */
  maxDepth: z.number().int().min(1).max(20).default(5),
  /** Branching factor — thoughts generated per expansion */
  branchingFactor: z.number().int().min(1).max(10).default(3),
  /** Minimum score threshold for keeping a thought (DFS pruning) */
  pruneThreshold: z.number().min(0).max(1).default(0.3),
  /** Maximum total thoughts before stopping */
  maxThoughts: z.number().int().min(1).default(50),
  /** Whether to allow thought aggregation (GoT-specific) */
  enableAggregation: z.boolean().default(true),
  /** Effort level for the LLM */
  effort: z.enum(["low", "medium", "high", "max"]).default("high"),
});

export type GoTConfig = z.infer<typeof GoTConfigSchema>;

// ============================================================
// GoT Result
// ============================================================

/** Result from a GoT reasoning session */
export const GoTResultSchema = z.object({
  /** The final answer/best thought */
  answer: z.string(),
  /** Confidence in the answer */
  confidence: z.number().min(0).max(1),
  /** The full graph state */
  graphState: GraphReasoningStateSchema,
  /** Summary of the reasoning process */
  reasoningSummary: z.string(),
  /** Statistics about the search */
  stats: z.object({
    totalThoughts: z.number(),
    thoughtsExplored: z.number(),
    thoughtsPruned: z.number(),
    aggregationsMade: z.number(),
    refinementsMade: z.number(),
    maxDepthReached: z.number(),
    totalTokens: z.number(),
    totalDurationMs: z.number(),
    generationErrors: z.number().default(0),
    evaluationErrors: z.number().default(0),
  }),
});

export type GoTResult = z.infer<typeof GoTResultSchema>;
